import json
import re
import requests
from pathlib import Path
import base64
import struct

# Constants
PROGRAM_ID = "4dWhc3nkP4WeQkv7ws4dAxp6sNTBLCuzhTGTf1FynDcf"
RPC_URL = "https://api.mainnet-beta.solana.com"

def get_account_info(pubkey: str):
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getAccountInfo",
        "params": [
            pubkey,
            {
                "encoding": "base64",
                "commitment": "confirmed"
            }
        ]
    }
    response = requests.post(RPC_URL, json=payload)
    return response.json()

def main():
    # Load IDL
    script_dir = Path(__file__).parent
    idl_path = script_dir.parent / "data" / "programs" / "ubclaunchpad.json"
    with open(idl_path) as f:
        idl = json.load(f)

    # Load SwarmData from info.tsx
    info_path = script_dir.parent / "data" / "swarms" / "info.tsx"
    with open(info_path, 'r') as f:
        content = f.read()
        # Extract SwarmData array using regex
        match = re.search(r'export const SwarmData: SwarmInfo\[\] = (\[[\s\S]*?\]);', content)
        if not match:
            raise Exception("Could not find SwarmData in info.tsx")
        swarm_data = json.loads(match.group(1))

    # Process each swarm
    for swarm in swarm_data:
        if not swarm.get('pool'):
            continue

        try:
            response = get_account_info(swarm['pool'])
            if 'error' in response:
                print(f"Error fetching account info for {swarm['name']}: {response['error']}")
                continue
                
            if not response['result']['value']:
                print(f"No account info found for {swarm['name']}")
                continue

            # Decode base64 data
            data = base64.b64decode(response['result']['value']['data'][0])
            
            # Parse account data - skip 8 byte discriminator
            data = data[8:]
            
            # Parse total_shares and available_shares (both u64)
            # Skip pool_name and admin_authority
            offset = 32 + 32  # Skip string data and pubkey
            total_shares = int.from_bytes(data[offset:offset+8], 'little')
            available_shares = int.from_bytes(data[offset+8:offset+16], 'little')
            
            sold_shares = total_shares - available_shares
            cycle = sold_shares // 5000
            multiple = pow(1.35, cycle)
            
            print(f"{swarm['name']}: {multiple:.2f}x multiple ({sold_shares} shares sold)")
            
            swarm['multiple'] = round(multiple * 100) / 100  # Round to 2 decimal places
        except Exception as e:
            print(f"Error processing {swarm['name']}: {str(e)}")

    # Write updated data back to file
    file_content = f"""// Auto-generated by update_multiples.py
import {{ SwarmInfo }} from "@/components/swarms/swarm.types";
import {{ KinKongDescription }} from "./descriptions/kinkong";
import {{ SwarmVenturesDescription }} from "./descriptions/swarmventures";
import {{ TerminalVelocityDescription }} from "./descriptions/terminalvelocity";
import {{ SyntheticSoulsDescription }} from "./descriptions/syntheticsouls";
import {{ DuoAIDescription }} from "./descriptions/duoai";

export const getSwarmUsingId = (swarmId: string) => SwarmData.find(swarm => swarm.id === swarmId);
export const getSwarmUsingPoolId = (poolId: string) => {{
    // First try direct pool match
    const swarm = SwarmData.find(swarm => swarm.pool === poolId);
    if (swarm) return swarm;

    // If no direct match, try program.pool match
    return SwarmData.find(swarm => swarm.program?.pool === poolId);
}};
export const getSwarmInfo = (swarmId: string) => SwarmData.find(swarm => swarm.id === swarmId);

export const SwarmData: SwarmInfo[] = {json.dumps(swarm_data, indent=2)};"""

    with open(info_path, 'w') as f:
        f.write(file_content)

    print('Multiples updated successfully!')

if __name__ == "__main__":
    main()
