import json
import re
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Commitment
from solana.publickey import PublicKey
import base58
import asyncio
import struct
from pathlib import Path

# Constants
PROGRAM_ID = "4dWhc3nkP4WeQkv7ws4dAxp6sNTBLCuzhTGTf1FynDcf"
RPC_URL = "https://api.mainnet-beta.solana.com"

async def main():
    # Load IDL
    script_dir = Path(__file__).parent
    idl_path = script_dir.parent / "data" / "programs" / "ubclaunchpad.json"
    with open(idl_path) as f:
        idl = json.load(f)

    # Load SwarmData from info.tsx
    info_path = script_dir.parent / "data" / "swarms" / "info.tsx"
    with open(info_path, 'r') as f:
        content = f.read()
        # Extract SwarmData array using regex
        match = re.search(r'export const SwarmData: SwarmInfo\[\] = (\[[\s\S]*?\]);', content)
        if not match:
            raise Exception("Could not find SwarmData in info.tsx")
        swarm_data = json.loads(match.group(1))

    # Setup Solana connection
    connection = AsyncClient(RPC_URL, commitment=Commitment("confirmed"))

    # Process each swarm
    for swarm in swarm_data:
        if not swarm.get('pool'):
            continue

        try:
            pool_pubkey = PublicKey(swarm['pool'])
            account_info = await connection.get_account_info(pool_pubkey)
            
            if not account_info.value:
                print(f"No account info found for {swarm['name']}")
                continue

            # Parse account data - skip 8 byte discriminator
            data = account_info.value.data[8:]
            
            # Parse total_shares and available_shares (both u64)
            # Skip pool_name and admin_authority
            offset = 32 + 32  # Skip string data and pubkey
            total_shares = int.from_bytes(data[offset:offset+8], 'little')
            available_shares = int.from_bytes(data[offset+8:offset+16], 'little')
            
            sold_shares = total_shares - available_shares
            cycle = sold_shares // 5000
            multiple = pow(1.35, cycle)
            
            print(f"{swarm['name']}: {multiple:.2f}x multiple ({sold_shares} shares sold)")
            
            swarm['multiple'] = round(multiple * 100) / 100  # Round to 2 decimal places
        except Exception as e:
            print(f"Error processing {swarm['name']}: {str(e)}")

    # Write updated data back to file
    file_content = f"""// Auto-generated by update_multiples.py
import {{ SwarmInfo }} from "@/components/swarms/swarm.types";
import {{ KinKongDescription }} from "./descriptions/kinkong";
import {{ SwarmVenturesDescription }} from "./descriptions/swarmventures";
import {{ TerminalVelocityDescription }} from "./descriptions/terminalvelocity";
import {{ SyntheticSoulsDescription }} from "./descriptions/syntheticsouls";
import {{ DuoAIDescription }} from "./descriptions/duoai";

export const getSwarmUsingId = (swarmId: string) => SwarmData.find(swarm => swarm.id === swarmId);
export const getSwarmUsingPoolId = (poolId: string) => {{
    // First try direct pool match
    const swarm = SwarmData.find(swarm => swarm.pool === poolId);
    if (swarm) return swarm;

    // If no direct match, try program.pool match
    return SwarmData.find(swarm => swarm.program?.pool === poolId);
}};
export const getSwarmInfo = (swarmId: string) => SwarmData.find(swarm => swarm.id === swarmId);

export const SwarmData: SwarmInfo[] = {json.dumps(swarm_data, indent=2)};"""

    with open(info_path, 'w') as f:
        f.write(file_content)

    print('Multiples updated successfully!')
    await connection.close()

if __name__ == "__main__":
    asyncio.run(main())
